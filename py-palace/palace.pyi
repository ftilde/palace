# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import os
import pathlib
import typing
from enum import Enum, auto

class Button:
    ...

class ChunkSize:
    ...

class ChunkSizeFull:
    ...

class ComboBox:
    ...

class EmbeddedTensorOperator:
    inner: TensorOperator
    embedding_data: TensorEmbeddingData

class Events:
    ...

class GuiRenderState:
    ...

class GuiState:
    ...

class Horizontal:
    ...

class ImageViewerState:
    offset: Vector
    zoom_level: float

class LODTensorOperator:
    levels: list[EmbeddedTensorOperator]

class Label:
    ...

class OnKeyPress:
    ...

class OnMouseClick:
    ...

class OnMouseDrag:
    ...

class OnWheelMove:
    ...

class RaycasterConfig:
    lod_coarseness: float
    preview_lod_coarseness_modifier: float
    oversampling_factor: float
    compositing_mode: CompositingMode
    shading: Shading

class RunTime:
    ...

class ScalarOperator:
    ...

class Slider:
    ...

class Splitter:
    ...

class TensorEmbeddingData:
    ...

class TensorMetaData:
    ...

class TensorOperator:
    ...

class TransFuncOperator:
    min: float
    max: float
    table: TensorOperator

class Vertical:
    ...

class CompositingMode(Enum):
    MOP = auto()
    DVR = auto()

class GuiNode(Enum):
    Button = auto()
    Slider = auto()
    Label = auto()
    ComboBox = auto()
    Horizontal = auto()
    Vertical = auto()

class JitArgument(Enum):
    Tensor = auto()
    Const = auto()

class MaybeEmbeddedTensorOperator(Enum):
    Not = auto()
    Embedded = auto()

class MaybeScalarDType(Enum):
    Scalar = auto()
    DType = auto()

class Shading(Enum):
    None = auto()
    Phong = auto()

class SliderVal(Enum):
    Array0 = auto()
    StoreRefF32 = auto()
    StoreRefU32 = auto()

def abs(vol:JitArgument) -> typing.Any:
    ...

def add(v1:JitArgument,v2:JitArgument) -> typing.Any:
    ...

def apply_tf(input:MaybeEmbeddedTensorOperator,tf:TransFuncOperator) -> typing.Any:
    ...

def cast(vol:JitArgument,to:MaybeScalarDType) -> typing.Any:
    ...

def entry_exit_points(input_md:TensorMetaData,embedding_data:TensorEmbeddingData,output_md:TensorMetaData,projection:Matrix) -> TensorOperator:
    ...

def gauss_kernel(stddev:float) -> TensorOperator:
    ...

def mandelbrot(md:TensorMetaData) -> LODTensorOperator:
    ...

def max(v1:JitArgument,v2:JitArgument) -> typing.Any:
    ...

def mean(vol:MaybeEmbeddedTensorOperator) -> ScalarOperator:
    ...

def mul(v1:JitArgument,v2:JitArgument) -> typing.Any:
    ...

def neg(vol:JitArgument) -> typing.Any:
    ...

def open_volume(path:str | os.PathLike | pathlib.Path,brick_size_hint:typing.Optional[int],volume_path_hint:typing.Optional[str]) -> EmbeddedTensorOperator:
    ...

def randomwalker(input:MaybeEmbeddedTensorOperator,seeds:TensorOperator,beta:float) -> typing.Any:
    ...

def rasterize_seed_points(points_fg:TensorOperator,points_bg:TensorOperator,md:TensorMetaData,ed:TensorEmbeddingData) -> EmbeddedTensorOperator:
    ...

def raycast(vol:LODTensorOperator,entry_exit_points:TensorOperator,config:typing.Optional[RaycasterConfig],tf:typing.Optional[TransFuncOperator]) -> TensorOperator:
    ...

def read_png(path:str | os.PathLike | pathlib.Path) -> TensorOperator:
    ...

def rechunk(tensor:MaybeEmbeddedTensorOperator,size:typing.Sequence[ChunkSize]) -> typing.Any:
    ...

def render_slice(input:LODTensorOperator,result_metadata:TensorMetaData,projection_mat:Matrix,tf:typing.Optional[TransFuncOperator]) -> TensorOperator:
    ...

def separable_convolution(tensor:MaybeEmbeddedTensorOperator,kernels:typing.Sequence[MaybeConstTensorOperator]) -> typing.Any:
    ...

def threshold(vol:MaybeEmbeddedTensorOperator,threshold:float) -> typing.Any:
    ...

def vesselness(vol:EmbeddedTensorOperator,min_scale:float,max_scale:float,steps:int) -> EmbeddedTensorOperator:
    ...

def view_image(image:LODTensorOperator,result_metadata:TensorMetaData,view_state:ImageViewerState) -> TensorOperator:
    ...

